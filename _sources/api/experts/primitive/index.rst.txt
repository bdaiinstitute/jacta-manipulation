:py:mod:`experts.primitive`
===========================

.. py:module:: experts.primitive

.. autoapi-nested-parse::

   
   PrimitiveSampler Submodule.


Module Contents
---------------

.. py:class:: PrimitiveSampler(plant: dexterity.jacta_planner.dynamics.mujoco_dynamics.MujocoPlant, graph: dexterity.jacta_planner.planner.graph.Graph, params: dexterity.jacta_planner.planner.parameter_container.ParameterContainer, actions_func: str, **actions_func_kwargs: Dict)


   Bases: :py:obj:`dexterity.jacta_planner.experts.expert_sampler.ExpertSampler`

   
   PrimitiveSampler object.

   A 'primitive' is a higher-level action type that entails multiple
   low-level actuator actions to reach some subgoal.  It is meant to represent
   manipulation primitives such as "grasping", "pushing", etc. A
   PrimitiveSampler can compute the necessary low-level actions given an
   initial state, and iterative over individual actions in the proper sequence.
   .. py:method:: callback(node_ids: torch.IntTensor) -> numpy.ndarray

      
      Given node_ids (N,), returns actions (N, na).

      Note that if node_ids contains duplicates, then we should
      be returning the same action for them, since they are the
      same nodes (representing the same stage in the primitive execution).

   .. py:method:: compute_low_level_actions(state: torch.FloatTensor, node_id: int) -> List

      
      Compute complete action trajectory.

      NOTE/TODO: action_time is currently ignored; whatever the action_sampler
      function computes as action_time will overwrite the returned values here.

   .. py:method:: reset() -> None

      
      Clear action_seqs, origins, and ongoing for new trajectory.


