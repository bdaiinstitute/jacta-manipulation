:py:mod:`visualizers.viser_app.controllers.sampling_base`
=========================================================

.. py:module:: visualizers.viser_app.controllers.sampling_base


Module Contents
---------------

.. py:data:: MAX_NUM_TRACES
   :value: 5

   

.. py:class:: SamplingBaseConfig


   Bases: :py:obj:`jacta.visualizers.viser_app.controllers.controller.ControllerConfig`

   
   Base controller config with spline parameters.
   .. py:attribute:: horizon
      :type: float
      :value: 1.0

      

   .. py:attribute:: num_nodes
      :type: int
      :value: 3

      

   .. py:attribute:: num_rollouts
      :type: int
      :value: 32

      

   .. py:attribute:: spline_order
      :type: Literal[zero, slinear, cubic]
      :value: 'slinear'

      

   .. py:attribute:: control_freq
      :type: float
      :value: 20.0

      

   .. py:attribute:: use_noise_ramp
      :type: bool
      :value: False

      


.. py:class:: SamplingBase(task: jacta.visualizers.viser_app.tasks.task.Task, config: SamplingBaseConfig, reward_config: jacta.visualizers.viser_app.tasks.task.TaskConfig)


   Bases: :py:obj:`jacta.visualizers.viser_app.controllers.controller.Controller`

   
   Base class for all sampling controller implementations.
   .. py:property:: num_timesteps
      :type: int

      
      Helper function to recalculate the number of timesteps for simulation

   .. py:property:: rollout_times
      :type: numpy.ndarray

      
      Helper function to calculate the rollout times based on the horizon length

   .. py:property:: spline_timesteps
      :type: numpy.ndarray

      
      Helper function to create new timesteps for spline queries.

   .. py:property:: spline
      :type: scipy.interpolate.interp1d

      
      Spline defining the current control signal to be applied.

   .. py:property:: controls
      :type: numpy.ndarray

      
      Contains the control signals applied in the current rollout.

   .. py:method:: resize_data() -> None

      
      Resize states, sensors, and models to (config.num_rollouts, num_timesteps, ...).

   .. py:method:: update_action(curr_state: numpy.ndarray, curr_time: float, additional_info: dict[str, Any]) -> None
      :abstractmethod:

      
      Abstract method for updating controller actions from current state/time.

   .. py:method:: action(time: float) -> numpy.ndarray
      :abstractmethod:

      
      Abstract method for querying current action from controller.

   .. py:method:: update_spline(times: numpy.ndarray, controls: numpy.ndarray) -> None

      
      Update the spline with new timesteps / controls.

   .. py:method:: set_default_controls() -> None

      
      Set default value for the Controller.controls. if there is no default value set to zero.

   .. py:method:: reset() -> None

      
      Reset the controls, candidate controls and the spline to their default values.

   .. py:method:: update_traces() -> None

      
      Update traces by extracting data from sensors readings.

      We need to have num_spline_points - 1 line segments. Sensors will initially be of shape
      (num_rollout x num_timesteps * num_physics_substeps x nsensordata) and needs to end up being in shape
      (num_elite * num_trace_sensors * size of a single rollout x 2 (first and last point of spline) x 3 (3d pos))


.. py:function:: make_spline(times: numpy.ndarray, controls: numpy.ndarray, spline_order: str) -> scipy.interpolate.interp1d

   
   Helper function for creating spline objects.

   :param times: array of times for knot points, shape (T,).
   :param controls: (possibly batched) array of controls to interpolate, shape (..., T, m).
   :param spline_order: Order to use for interpolation. Same as parameter for scipy.interpolate.interp1d.
   :param extrapolate: Whether to allow extrapolation queries. Default true (for re-initialization).

