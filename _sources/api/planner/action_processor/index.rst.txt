:py:mod:`planner.action_processor`
==================================

.. py:module:: planner.action_processor


Module Contents
---------------

.. py:class:: ActionProcessor


   
   ActionProcessor
   .. py:attribute:: params
      :type: benedict.benedict

      

   .. py:attribute:: actuated_pos
      :type: torch.IntTensor

      

   .. py:method:: get_start_actions(current_actuated_states: Optional[torch.FloatTensor] = None, previous_end_actions: Optional[torch.FloatTensor] = None) -> torch.FloatTensor

      
      Compute start action or previous end action

      Compute start action based on current state or previous end action
      depending on the action_start_mode parameter.

   .. py:method:: get_end_actions(relative_actions: torch.FloatTensor, action_type: Optional[dexterity.planner.planner.types.ActionType] = None, current_actuated_states: Optional[torch.FloatTensor] = None, previous_end_actions: Optional[torch.FloatTensor] = None) -> torch.FloatTensor

      
      Compute end action

      Compute end action as absolute action or relative to current state or previous end action.
      The computation depends on the action_end_mode parameter.

   .. py:method:: get_action_trajectories(start_actions: torch.FloatTensor, end_actions: torch.FloatTensor) -> torch.FloatTensor

      
      Create and return action trajectories

      :param start_actions: Array containing the start action vectors of the desired trajectories
      :type start_actions: FloatTensor
      :param end_actions: Array containing the end action vectors of the desired trajectories
      :type end_actions: FloatTensor

      :returns: *FloatTensor* -- An action vector array (n, trajectory_steps, na)

   .. py:method:: get_actuated_states(current_states: torch.FloatTensor) -> torch.FloatTensor

      
      Return actuated states

      :param current_states: Current states
      :type current_states: FloatTensor

      :returns: *FloatTensor* -- Actuated

   .. py:method:: __call__(relative_actions: torch.FloatTensor, action_type: dexterity.planner.planner.types.ActionType | None = None, current_states: torch.FloatTensor | None = None, previous_end_actions: torch.FloatTensor | None = None) -> torch.FloatTensor

      
      Makes the class Callable. On call, return action trajectories

      :param relative_actions: Relative actions
      :type relative_actions: FloatTensor
      :param action_type: Action type. Defaults to None.
      :type action_type: ActionType | None, optional
      :param current_states: Current states. Defaults to None.
      :type current_states: FloatTensor | None, optional
      :param previous_end_actions: Previous end actions. Defaults to None.
      :type previous_end_actions: FloatTensor | None, optional

      :returns: *FloatTensor* -- *description*


.. py:class:: SpotFloatingActionProcessor


   Bases: :py:obj:`ActionProcessor`

   
   SpotFloatingActionProcessor
   .. py:attribute:: base_action_ixs
      :type: slice

      

   .. py:attribute:: arm_action_ixs
      :type: slice

      

   .. py:method:: get_end_actions(relative_actions: torch.FloatTensor, action_type: Optional[dexterity.planner.planner.types.ActionType] = None, current_actuated_states: Optional[torch.FloatTensor] = None, previous_end_actions: Optional[torch.FloatTensor] = None) -> torch.FloatTensor

      
      Computes end action for Spot with floating base.

      Given relative actions in polar coordinates it computes the absolute action
      for the floating base motion.

   .. py:method:: base_action_to_egocentric(relative_actions: torch.FloatTensor, current_actuated_states: torch.FloatTensor) -> torch.FloatTensor

      
      Convert robot floating base world frame actions to robot frame "egocentric" actions.

   .. py:method:: clip_base_actions(base_action: torch.FloatTensor) -> torch.FloatTensor

      
      Clips based on clipping type

      :param base_action: Base action
      :type base_action: FloatTensor

      :returns: *FloatTensor* -- Clipped base action


.. py:class:: SpotWholebodyActionProcessor


   Bases: :py:obj:`ActionProcessor`

   
   SpotWholebodyActionProcessor
   .. py:attribute:: base_action_ixs
      :type: slice

      

   .. py:attribute:: arm_action_ixs
      :type: slice

      

   .. py:attribute:: arm_state_ixs

      
      Action processor for the Spot robot with wholebody control.
      Uses vx, vy, vtheta to control the locomotion policy powered plant which handles the leg control.

   .. py:method:: get_actuated_states(current_states: torch.FloatTensor) -> torch.FloatTensor

      
      Gets actuated states from the current states

      :param current_states: Current states
      :type current_states: FloatTensor

      :returns: *FloatTensor* -- Actuated states

   .. py:method:: get_start_actions(current_actuated_states: Optional[torch.FloatTensor] = None, previous_end_actions: Optional[torch.FloatTensor] = None) -> torch.FloatTensor

      
      Get start actions for the ARM.

   .. py:method:: get_action_trajectories(start_actions: torch.FloatTensor, end_actions: torch.FloatTensor) -> torch.FloatTensor

      
      Separately create trajectories for the base and the arm actions.

      Base actions are zero-order held, while arm actions are parameterized.


