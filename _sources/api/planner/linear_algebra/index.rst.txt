:py:mod:`planner.linear_algebra`
================================

.. py:module:: planner.linear_algebra


Module Contents
---------------

.. py:function:: transformation_matrix(rot: numpy.ndarray | None = None, pos: numpy.ndarray | None = None) -> numpy.ndarray

   
   Returns a 4x4 transformation matrix given rotation matrix and translation vector.

   :param rot: 3x3 rotation matrix.
   :type rot: array-like
   :param pos: Translation vector (3 elements).
   :type pos: array-like

   :returns: *numpy.ndarray* -- 4x4 transformation matrix.

.. py:function:: truncpareto_cdf(x: torch.IntTensor, exponent: float, upper_bound: int) -> torch.FloatTensor

   
   Truncated Pareto distribution.

.. py:function:: max_scaling(directions: torch.FloatTensor, action_range: torch.FloatTensor) -> torch.FloatTensor

   
   Compute maximum scaling values so that directions fits within the action range.

   :param directions: [num_directions, action_dim]
   :param action_range: [action_dim]

.. py:function:: normalize(direction: torch.FloatTensor) -> torch.FloatTensor

   
   Normalize a vector across all its dimensions.

   Typically this is applied to one-dimensional vectors.

.. py:function:: normalize_multiple(directions: torch.FloatTensor) -> torch.FloatTensor

   
   Normalize vectors along the last dimension.

.. py:function:: project_v_on_u(v: torch.FloatTensor, u: torch.FloatTensor) -> torch.FloatTensor

   
   Calculates the projection of v on u.

   :raises A ValueError if v and u are not vectors:

.. py:function:: gram_schmidt(basis_vectors: torch.FloatTensor) -> torch.FloatTensor

   
   Returns an orthonormal basis spanning the same dimension as the linearly independent basis vectors.

   This method assumes the basis vectors are linearly independent. If they aren't, you're going to have a bad time

   :param basis_vectors: set of vectors that span a space. The columns are assumed to be individual vectors

   :raises An ValueError if the basis vectors are not linearly independent:

.. py:function:: project_vectors_on_eigenspace(vectors: torch.FloatTensor, orthonormal_basis: torch.FloatTensor) -> torch.FloatTensor

   
   Given an eigenspace, projects the vector on the space.

   :param vectors: (k, n) vector
   :type vectors: FloatTensor
   :param orthonormal_basis: (m, n) sized orthonormal basis
   :type orthonormal_basis: FloatTensor

   :returns: *FloatTensor* -- (k, n) vectors projected on the orthonormal basis

.. py:function:: einsum_ij_ij_i(A: torch.FloatTensor, B: torch.FloatTensor) -> torch.FloatTensor

   
   Transpose the first vector of each of the i vector-vector pairs and then multiply them

   i (j,) vectors, i (j,) vectors -> i scalars

   :param A: Input vector A
   :type A: FloatTensor
   :param B: Input vector B
   :type B: FloatTensor

   :returns: *FloatTensor* -- Transposed vector

.. py:function:: einsum_ij_kj_ki(A: torch.FloatTensor, B: torch.FloatTensor) -> torch.FloatTensor

   
   Multiply the matrix with each of the k vectors

   1 (i,j) matrix, k (j,) vectors -> k (i,) vectors

   :param A: Input matrix A
   :type A: FloatTensor
   :param B: Input matrix B
   :type B: FloatTensor

   :returns: *FloatTensor* -- Output matrix

.. py:function:: einsum_ijk_ik_ij(A: torch.FloatTensor, B: torch.FloatTensor) -> torch.FloatTensor

   
   Multiply each of the i matrix-vector pairs

   i (j,k) matrices, i (k,) vectors -> i (j,) vectors

   :param A: Input matrix-vector A
   :type A: FloatTensor
   :param B: Input matrix-vector B
   :type B: FloatTensor

   :returns: *FloatTensor* -- Output matrix-vector

.. py:function:: einsum_ikj_ik_ij(A: torch.FloatTensor, B: torch.FloatTensor) -> torch.FloatTensor

   
   Transpose the matrix of each matrix-vector pair and then multiply them

   i (k,j) matrices, i (k,) vectors -> i (j,) vectors

   :param A: Input matrix-vector A
   :type A: FloatTensor
   :param B: Input matrix-vector B
   :type B: FloatTensor

   :returns: *FloatTensor* -- Transposed matrix

.. py:function:: einsum_jk_ikl_ijl(A: torch.FloatTensor, B: torch.FloatTensor) -> torch.FloatTensor

   
   Multiply the matrix with each of the i matrices

   1 (j,k) matrices, i (k,l) matrices -> i (j,l) matrices

   :param A: Input matrix A
   :type A: FloatTensor
   :param B: Input matrix B
   :type B: FloatTensor

   :returns: *FloatTensor* -- Output matrix

.. py:function:: einsum_ijk_ikl_ijl(A: torch.FloatTensor, B: torch.FloatTensor) -> torch.FloatTensor

   
   Multiply each of the i matrix-matrix pairs

   i (j,k) matrices, i (k,l) matrices -> i (j,l) matrices

   :param A: Input matrix A
   :type A: FloatTensor
   :param B: Input matrix B
   :type B: FloatTensor

   :returns: *FloatTensor* -- Output matrix

.. py:function:: einsum_ikj_ikl_ijl(A: torch.FloatTensor, B: torch.FloatTensor) -> torch.FloatTensor

   
   Transpose the first matrix of each of the i matrix-matrix pairs and then multiply them

   i (k,j) matrices, i (k,l) matrices -> i (j,l) matrices

   :param A: Input matrix A
   :type A: FloatTensor
   :param B: Input matrix B
   :type B: FloatTensor

   :returns: *FloatTensor* -- Output matrix

.. py:function:: einsum_ijk_ilk_ijl(A: torch.FloatTensor, B: torch.FloatTensor) -> torch.FloatTensor

   
   Transpose the second matrix of each of the i matrix-matrix pairs and then multiply them

   i (j,k) matrices, i (l,k) matrices -> i (j,l) matrices

   :param A: Input matrix A
   :type A: FloatTensor
   :param B: Input matrix B
   :type B: FloatTensor

   :returns: *FloatTensor* -- Output matrix

